Le collezioni sono gestite in due modi: array, hash.

Array
il metodo [] è in sostanza un getter, mentre il metodo []= è un setter.

Se gli passo un indice negativo, conta al contrario.

Se all'interno di un'array creo dei gap, questi vengono colmati con dei nil.
a[0]=a [2]=c --> a[1]=nil

getter
Posso anche specificargli degli estremi in modo che vengano presi gli elementi tra gli estremi (sempre presi da sinistra
a destra):
a[1..3] -> prende gli elementi dalla posizione 1 alla 3 compresa
a[1...3], a[-3..-1], a[4..-2]
a[-2..1] -> torna [] se la posizione del primo estremo è dopo quella del secondo. In sostanza non fa il giro!

Oppure posso partire da una certa posizione e prendere tot elementi:
a[2, 4] parte dalla posizione 2 e ne prende in tutto 4.
Oss. In generale quindi a[2..4] != a[2, 4]

setter
Se come indicizzazione uso due numeri o un range allora gli elementi nell'array originario sono sostituiti con tutto
ciò che sta a destra dell'assegnamento.
a[1]=[1,2,3] -> in posizione 1 metterà un array con valori [1,2,3]
a[2, 2] = 'x' -> dalla posizione due, prendo in tutto due elementi, e li rimpiazzo con uno solo che vale x.
a[2, 0] = 'y' -> inserisco y davanti al secondo elemento.
a[1, 1] = [9, 8, 7] -> occhio, è diverso dal primo esempio. Qui mi metto in posizione 1 e rimpiazzo quel singolo
                       elemento con tre elementi: 9, 8, 7.
a[0..3] = [] -> butto i primi 4 elementi dell'array.
a[1..2] = 99, 98, 100 -> da elemento 1 fino a 2 rimpiazzo con i tre elementi 99, 98, 100

Gli array hanno molti metodi e possono essere usati come stack, queue, ecc. Infatti dispongono dei metodi push, pop,
shift, ecc.

per tornare i primi o gli ultimi elementi di un array posso usare
a.first(2) # i primi due
a.last(3) # gli ultimi 3

Riassumendo, posso usare queste modalità di getter e setter:
a[n]
a[n..m]
a[n, m]

------------------------------------------------------------------------------------------------------------------------

Hash
Per indicizzare le chiavi
'key' => 'value'
:key => 'value'
key: 'value' # shortcut per il precedente

NB - differente da altri linguaggi: ruby si ricorda l'ordine di inserimento degli elementi nella hash, quindi posso fare
affidamento sull'ordinamento!

------------------------------------------------------------------------------------------------------------------------

Blocchi e Iteratori

Un ITERATOR è un metodo che chiama un blocco di codice ripetutamente. (Es: each)

Blocchi
Il blocco è semplicemente un pezzo di codice.
Come succede per un metodo, il blocco può prendere dei parametri. {|p1, p2| ...}
Metodo {blocco}, metodo(parametri) {blocco} Possiamo pensarlo come ad un parametro extra passato al metodo.
Scope: Se c'è una variabile all'interno del blocco con lo stesso nome di una variabile nello stesso scope ma all'esterno
       del blocco, le due sono la stessa cosa.
       Se la variabile compare solo nel blocco all'ora vive solo nello scope del blocco.
       I parametri del blocco, sono sempre locali al blocco anche se hanno lo stesso nome di una variabile definita al
       di fuori del blocco.
       Posso definire delle variabili locali al blocco cos': {|value; suqare|}


