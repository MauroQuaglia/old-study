Le collezioni sono gestite in due modi: array, hash.

Array
il metodo [] è in sostanza un getter, mentre il metodo []= è un setter.

Se gli passo un indice negativo, conta al contrario.

Se all'interno di un'array creo dei gap, questi vengono colmati con dei nil.
a[0]=a [2]=c --> a[1]=nil

getter
Posso anche specificargli degli estremi in modo che vengano presi gli elementi tra gli estremi (sempre presi da sinistra
a destra):
a[1..3] -> prende gli elementi dalla posizione 1 alla 3 compresa
a[1...3], a[-3..-1], a[4..-2]
a[-2..1] -> torna [] se la posizione del primo estremo è dopo quella del secondo. In sostanza non fa il giro!

Oppure posso partire da una certa posizione e prendere tot elementi:
a[2, 4] parte dalla posizione 2 e ne prende in tutto 4.
Oss. In generale quindi a[2..4] != a[2, 4]

setter
Se come indicizzazione uso due numeri o un range allora gli elementi nell'array originario sono sostituiti con tutto
ciò che sta a destra dell'assegnamento.
a[1]=[1,2,3] -> in posizione 1 metterà un array con valori [1,2,3]
a[2, 2] = 'x' -> dalla posizione due, prendo in tutto due elementi, e li rimpiazzo con uno solo che vale x.
a[2, 0] = 'y' -> inserisco y davanti al secondo elemento.
a[1, 1] = [9, 8, 7] -> occhio, è diverso dal primo esempio. Qui mi metto in posizione 1 e rimpiazzo quel singolo
                       elemento con tre elementi: 9, 8, 7.
a[0..3] = [] -> butto i primi 4 elementi dell'array.
a[1..2] = 99, 98, 100 -> da elemento 1 fino a 2 rimpiazzo con i tre elementi 99, 98, 100

Gli array hanno molti metodi e possono essere usati come stack, queue, ecc. Infatti dispongono dei metodi push, pop,
shift, ecc.

per tornare i primi o gli ultimi elementi di un array posso usare
a.first(2) # i primi due
a.last(3) # gli ultimi 3

Riassumendo, posso usare queste modalità di getter e setter:
a[n]
a[n..m]
a[n, m]

------------------------------------------------------------------------------------------------------------------------

Hash
Per indicizzare le chiavi
'key' => 'value'
:key => 'value'
key: 'value' # shortcut per il precedente

NB - differente da altri linguaggi: ruby si ricorda l'ordine di inserimento degli elementi nella hash, quindi posso fare
affidamento sull'ordinamento!

------------------------------------------------------------------------------------------------------------------------

Blocchi
Il blocco è semplicemente un pezzo di codice.
Come succede per un metodo, il blocco può prendere dei parametri. {|p1, p2| ...}
Metodo {blocco}, metodo(parametri) {blocco} Possiamo pensarlo come ad un parametro extra passato al metodo.

Scope:
Se c'è una variabile all'interno del blocco con lo stesso nome di una variabile nello stesso scope ma all'esterno
del blocco, le due sono la stessa cosa.
Se la variabile compare solo nel blocco all'ora vive solo nello scope del blocco.
I parametri del blocco, sono sempre locali al blocco anche se hanno lo stesso nome di una variabile definita al
di fuori del blocco.
Posso definire delle variabili locali al blocco così: {|item; x, y, z|} dove item è la variabile a cui viene passato
il valore dall'iterator e x, y e z sono variabili locali al blocco.

------------------------------------------------------------------------------------------------------------------------

Iterator
Un ITERATOR è un metodo che chiama un blocco di codice ripetutamente.
In sostanza chiamo l'iteretaor e gli passo un blocco (.each{|| ...})
Il blocco non viene eseguito nel momento in cui ruby lo incontra, tuttavia ruby si ricorda il contesto del blocco, le
sue variabili locali, ecc)
All'interno del metodo posso invocare il blocco con "yield"
Posso passare parametri al blocco: (yield param1, param2)
Posso ricevere valori dal blocco: Il valore dell'ultima espressione valutata nel blocco è ritornata.

NB: differenza con altri linguaggi
Vantaggio
la collezione in questione fa quello che sa fare meglio, ciò accedere ai suoi elementi. Devo solo
dirgli cosa fare con quegli elementi tramite il blocco. In altri linguaggi invece mi devo preoccupare anche del ciclo!
In ruby gli iteratori sono interni alla classe, in altri linguaggi mi devo far dare l'iteratore e poi mi devo
preoccupare di scorrere gli elementi.
Svantaggi
Se non posso gestire manualmente gli iteratori diventa difficile scorrere due collezioni contemporaneamente.
Soluzione: in queste occasioni abbiamo a disposizione la classe Enumerable che implementa un iteratore esterno. Basta
chiamare il metodo to_enum (o enum_for)

Esempi di iteratori
*each
il più semplice degli iteratori, passa al blocco gli elementi della sua collezione

*find
cerca il primo valore in una collezione che soddisfa la condizione del blocco, altrimenti torna nil.

* map (o collect, sono la stessa cosa. Uno è un alias dell'altro.)
passa ogni elemento al blocco e alla fine mi ritorna un array con tutti i nuovi valori

* inject
permette di accumulare valori, scorrendo una collezione.
Somma dei valori -> [3, 2, 1].inject(){|sum, x| sum + x}  # Parte a sommare dal  3.
Somma dei valori -> [3, 2, 1].inject(0){|sum, x| sum + x} # Parte a sommare da 0.
oppure posso anche specificare il metodo da chiamare agli elementi successivi della collezione.
Somma dei valori -> [3, 2, 1].inject(:+)

OSS.
Posso tenere traccia anche della posizione su cui sto iterando con il metodo "with_index"
L'iteratore ti passa il valore corrente, con la chiamata addizionale with_index ti viene passata anche la posizione.
"with_index" è un metodo addizionale, così che possiamo aggiungerlo a un qualsiasi iteratore.
Es.
each.with_index
find.with_index

------------------------------------------------------------------------------------------------------------------------

Enumerator
Sono iteratori esterni
Quasi tutti gli iterator, se chiamati senza blocco, ritornano l'enumerator.
Posso chiamare il metodo 'loop' che continua a richiamare l'enumerator finchè questo non ha finito. In generale però
devo fare attenzione, perché se non uso un enumerator lui continua indefinitamente a chiamare il blocco che ha
associato.

Modi per recuperare l'enumerator:
'xxx'.enum_for(:each_char)  # torna l'enumerator del metodo each_char
'xxx'.each_char             # se non gli passo il blocco torna l'enumeratore
'xxx'.to_enum               # occhio che qui torna l'enumerator del metodo each

Sugli enumeratori è definito il metodo each_with_index che ti da anche la posizione.






