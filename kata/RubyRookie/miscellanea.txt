* le {} hanno più precedenza rispetto al costrutto do-end
** a parte la precedenza per il resto sono identiche

* In ruby le stringhe sono mutabili in java sono immutabili

* ruby ha due built-in per gestire le collezioni, array e hash.

* in un array, con gli indici negativi parto dal fondo. se l'indice non c'è ritorna nil.
** con un array si possono simulare stack, sets, queues, dequeues, FIFO. Una struttura sola fa tutto!!!

* ALLELUJA ALLELUJA!!!
** ruby si ricorda l'ordine in cui gli elementi sono stati aggiunti in una hash! Se itero su una hash ritorna gli elementi nell'ordine in cui li ho inseriti!

* quando lavoro sulle chiavi delle hash, se le devo incrementare e aggiungere posso anche non mettere nessuna if
** basta inizializzare la hash con il default e poi fare words[token] += 1

* un iterator è un metodo che chiama un blocco di codice ripetitivamente (per esempio each)

* sintassi ruby
** indentazione: 2 spazi
** {} per blocchi di una righa; do-end per blocchi di più righe (occhio alle precedenze)

* all'interno di un blocco posso definire delle variabili locali al blocco ES: (|value; square|) value=parametro, square = variabile locale
* se la voglio inizializzare (|value; square = 0|)

ESEMPIO sui blocchi
* [1, 2, 3].find{ |x| x * x >= 90}
** il vantaggio è che la classe array fa quello che sa fare meglio, ciò accedere agli elementi dell'array, io devo solo passargli la condizione.
** normalmente invece mi devo preoccupare anche del ciclo!

* iteratori base di ruby
* each
 ** è l'iteratore di base, e quello più usato; itera solo gli elementi
 ** tutte le volte che uso un iteratore, se voglio anche l'indice basta fare each.with_index invece del solo each
 ** each.with_index(10) -> comincia a contare da 10
 ** each_with_index -> comincia a contare da 0, non posso parametrizzarlo!
* collect
** collect o map sono la stessa cosa, sono alias
* find
* inject
** inject() #parte dal valore del primo elemento
** inject(9) #parte dal valore passatogli, cioè 9
** esempio [2, 6, 8, 2].inject(:+)
*** posso anche solo specificare il nome del metodo che voglio applicare agli elementi successivi della collezione. In questo caso funziona perchè in ruby l'addizione è un metodo su un numero e :x è il simbolo che corrisponde al metodo +.
*** altro esempio [2, 7].inject(28, :div) -> 2 (valore iniziale 28, metodo da chiamare sulla successione div) AH, RUBY...

* iterator ed enumerator
** l'iterator è un costrutto interno. Viene usato dai metodi come each, collect, ...
** l'enumerator invece è un iteratore esterno. Può servire se devo iterare su più collezioni contemporaneamente. Mi faccio dare gli enumerator delle collezioni, poi li ciclo con il loop.
*** infatti con un iterator interno non posso ciclare su due collezioni contemporaneamente.
* diciamo così:
** iterator -> lo gestisce ruby
** enumerator -> lo gestisco io
* su un enumerator posso chiamare il metodo each_with_index. Quindi se mi serve un indice su una qualsiasi cosa basta che riesca a farmi dare
il suo enumerator e poi posso usare il metodo each_with_index. Per esempio la stringa 'cat'.each_char.each_with_index, oppure più compatto 'cat'.each_char.with_index)

* loop
** loop continua ad eseguire il ciclo finchè una condizione non è verificata.
** Con gli enumerator è furbo, quando ne ha raggiunto la fine esce dal ciclo.

* sintassi
** posso anche definire un blocco così: palindrome = -> n { n = n.to_s; n == n.reverse }
** e lo posso chiamare così Integer.all.select(&palindrome).first(10)

----
Blocchi
Posso memorizzare un blocco in un oggetto e usarlo quando mi serve.
Il blocco viene memorizzato in un oggetto Proc.
Ci sono due modi per convertire un blocco in un oggetto: "lambda" e "Proc.new" entrambe però ritornano un oggetto di tipo Proc.
* block1 = Proc.new {|p| p 'Proc.new ' + p}
* block2 = lambda {|p| p 'lambda ' + p}
* sono entrambe due oggetti di tipo Proc.
questi sono due oggetti (le differenze le vediamo dopo) e li invoco con call.

