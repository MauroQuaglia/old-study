* le {} hanno più precedenza rispetto al costrutto do-end
** a parte la precedenza per il resto sono identiche

* In ruby le stringhe sono mutabili in java sono immutabili

* ruby ha due built-in per gestire le collezioni, array e hash.

* in un array, con gli indici negativi parto dal fondo. se l'indice non c'è ritorna nil.
** con un array si possono simulare stack, sets, queues, dequeues, FIFO. Una struttura sola fa tutto!!!

* ALLELUJA ALLELUJA!!!
** ruby si ricorda l'ordine in cui gli elementi sono stati aggiunti in una hash! Se itero su una hash ritorna gli elementi nell'ordine in cui li ho inseriti!

* quando lavoro sulle chiavi delle hash, se le devo incrementare e aggiungere posso anche non mettere nessuna if
** basta inizializzare la hash con il default e poi fare words[token] += 1

* un iterator è un metodo che chiama un blocco di codice ripetitivamente (per esempio each)

* sintassi ruby
** indentazione: 2 spazi
** {} per blocchi di una righa; do-end per blocchi di più righe (occhio alle precedenze)

* all'interno di un blocco posso definire delle variabili locali al blocco ES: (|value; square|) value=parametro, square = variabile locale

ESEMPIO sui blocchi
[1, 2, 3].find{ |x| x * x >= 90}
# il vantaggio è che la classe array fa quello che sa fare meglio, ciò accedere agli elementi dell'array, io devo solo passargli la condizione.
# normalmente invece mi devo preoccupare anche del ciclo!

* iteratori base di ruby
* each
 ** è l'iteratore di base, e quello più usato. itera solo gli elementi
 ** tutte le volte che uso un iteratore, se voglio anche l'indice basta fare each.with_index invece del solo each
 ** each.with_index(10) -> comincia a contare da 10
 ** each_with_index -> comincia a contare da 0, non posso parametrizzarlo!
* collect
** collect o map sono la stessa cosa, sono alias
* find
* inject
** inject() #parte dal valore del primo elemento
** inject(9) #parte dal valore passatogli, cioè 9
** p [2, 6, 8, 2].inject(:+)
*** posso anche solo specificare il nome del metodo che voglio applicare agli elementi successivi della collezione. in questo caso funziona perchè in ruby l'addizione è un metodo su un numero e :x è il simbolo che corrisponde al metodo +.
*** altro esempio p [2, 7].inject(28, :div) -> 2 (valore iniziale, metodo da chiamare sulla successione) AH, RUBY...



