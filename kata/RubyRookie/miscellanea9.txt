Espressioni



Quello che per C# o Java è un'istruzione, per Ruby è un'espressione.
my_if = if 0 == 0
          'ciao'
         end
poi quando chiamo la my_if, la esegue.



Posso ridefinire un'operazione usando la parola alias:
class Fixnum
  alias old_plus +
end
2 + 5 = 7
2.old_plus(5) = 7

class Fixnum
  alias old_plus +
  def +(other)
    self.succ
  end
end
1 + 3 = 2
1.old_plus(3) = 4



Posso definire su una mia classi tutti i metodi che voglio, come quelli usati normalmente:
<< (che poi torna self), [] indexing



Se uso `` (backticks) o %x{} posso eseguire un comando relativo al mio sistema operativo
l'exit status è disponibile nella variabile $?
OSS:
anche ` è un metodo e può essere ridefinito.
Posso scriverlo ovunque senza specificare che riapro Object ()

alias old_backquote `
def `(cmd)
  result = old_backquote(cmd)
  if $? != 0
    puts "Command: [#{cmd}] failed with status: [#{$?.exitstatus}]!"
  end
  result
end



Assegnamento
semplice: a = 7 (a è una variabile o costante)
complesso: list.projects = [1,2] dove vado io ad implementare il setting projects sull'oggetto list.
il valore dell'assegnazione è sempre il valore del parametro, anche si poi ci metto un return!


Con Ruby si possono fare assegnazioni parallele.
a sx posso avere solo uno splat, a dx anche più di uno.
a, b, c, d = *(1..4)
a, *b = 1, 2, 3, *[1, 9]
g, *a, b = 1, 3, 9, 5
posso anche ignorare dei parametri con il solo asterisco
f, *, l = *(1..10)      f = 1, l = 10
Ci possono essere anche degli assegnamenti innestati
a, (b, c), d = 1, 2, 3, 4
a = 1
(b, c) = 2 -> b=2, c=nil
d=3




