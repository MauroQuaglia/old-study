Espressioni



Quello che per C# o Java è un'istruzione, per Ruby è un'espressione.
my_if = if 0 == 0
          'ciao'
         end
poi quando chiamo la my_if, la esegue.



Posso ridefinire un'operazione usando la parola alias:
class Fixnum
  alias old_plus +
end
2 + 5 = 7
2.old_plus(5) = 7

class Fixnum
  alias old_plus +
  def +(other)
    self.succ
  end
end
1 + 3 = 2
1.old_plus(3) = 4



Posso definire su una mia classi tutti i metodi che voglio, come quelli usati normalmente:
<< (che poi torna self), [] indexing



Se uso `` (backticks) o %x{} posso eseguire un comando relativo al mio sistema operativo
l'exit status è disponibile nella variabile $?
OSS:
anche ` è un metodo e può essere ridefinito.
Posso scriverlo ovunque senza specificare che riapro Object ()

alias old_backquote `
def `(cmd)
  result = old_backquote(cmd)
  if $? != 0
    puts "Command: [#{cmd}] failed with status: [#{$?.exitstatus}]!"
  end
  result
end



Assegnamento
semplice: a = 7 (a è una variabile o costante)
complesso: list.projects = [1,2] dove vado io ad implementare il setting projects sull'oggetto list.
il valore dell'assegnazione è sempre il valore del parametro, anche si poi ci metto un return!


Con Ruby si possono fare assegnazioni parallele.
a sx posso avere solo uno splat, a dx anche più di uno.
a, b, c, d = *(1..4)
a, *b = 1, 2, 3, *[1, 9]
g, *a, b = 1, 3, 9, 5
posso anche ignorare dei parametri con il solo asterisco
f, *, l = *(1..10)      f = 1, l = 10
Ci possono essere anche degli assegnamenti innestati
a, (b, c), d = 1, 2, 3, 4
a = 1
(b, c) = 2 -> b=2, c=nil
d=3



gli operatori ++ e -- non ci sono.
usiamo += e -=
tutto ciò che non è nil o false e true.

&&, and -> fanno la stessa cosa ma differiscono per priorità... similmente gli altri
and e && ritornano il primo membro se false, atrimenti valutano ed eventualmente ritornano il secondo membro.
nil && 99 = nil, true && 99 = 99
or e || ritornano il primo membro se true, atrimenti valutano ed eventualmente ritornano il secondo membro.
nil || 99 #99
'ciao' || nil # ciao

Un idioma comune è assegnare un valore a una variabile solo se non è ancora assegnato.
var ||= 'default' (che è uno shortcut per una cosa simile a var = var || 'default')
anche se le due espressioni sono leggermente differenti.
con ||= se la variabile è già settatat non viene fatto nessun assegnamento, con v = v || 'd' l'assegnamento viene fatto comunque.




defined?
nil se l'argomento non è definito
una descrizione se l'argomento è definito.
defined? 1 -> espressione
defined? x -> nil
defined? print -> method

gli oggetti ruby supportano il confronto grazie ai metodi
==, ===, <=>, =~, eql?, equal? -> tutti in classe object tranne <=>
OSS:
== stesso valore 1 == 1.0 ok
=== stesso tipo di base e valore:    VERO  1 === 1.0 # numeric di base e 1 di valore
eql? stesso tipo e valore:   FALSO 1.eql?(1.0) # integer e float
equal? stesso oggetto


ci sono anche le versioni negate di ==, != e =~, !~
# se le negazioni non sono definite, ruby cerca la definizione di == e nega il risultato. Vedi class T di esempio.


IF
la keyword then è opzionale se vado a capo. Se metto tutto su una linea allora ci vuole.
if, then, elsif, else, end. Sono le varie keyword che si possono usare
dato che la if è un'espressione, essa ritorna un valore e questo può essere memorizzato in una variabile
unless = if not
c'è anche l'operatore ternario.... condition ? true : false
id e unless possono anche essere messi alla fine di uno statements. return 'c' if ...



CASE
praticamente una if con steroidi... una multi-if.
case, when, then, else, ,, end
la keyword then si usa se voglio scrivere tutto su una riga, se vado a capo non serve.
case a
    when 1...10   then p 'ciao'
posso usare la virgola per separare più condizioni con lo stesso output.    when 1, 2
NB: la comparazione del valore con il target è fatto dal case usando l'operatore ===
posso valutare sia le singole when che solo il case
1) case
when XXX=AAA
when YYY=BBB
when ZZZ=CCC
2)
case VALUE
when XXX
when YYY
il case ritorna l'ultima operazione eseguita quindi la posso memorizzare.
OSS.
l'operatore === è definito nelle classi (Class) e si può usare per controllare se il tipo della classe è lo stesso di un'altra
SI USA ANCHE CON LE CLASSI DERIVATE



-LOOPS- (while ed until sono le uniche primitive per il loop )
WHILE eseguo finché è true la condizione
UNTIL eseguo finchè è false la condizione
Entrambi si possono usare alla fine di uno statements: a += 1 while a <= 3
per fare scattare il while almeno una volta posso usare il begin end (do..while in C#)

OSS: il range .. è come un interruttore
ritorna true quando il primo evento succede e rimane true finche il secondo evento non succede.
File.foreach('numbers.txt') do |line|
    puts(line) if line =~ /two/ .. /five/
end
mi scrive  two three four five
Dato che gli estremi del range vengono valutati tutte le volte posso anche usare espressioni combinate



ITERATORI
OSS. in ruby il FOR non c'è come iteratore esterno, ma compare spesso come iteratore interno, in modo che sia più difficile commettere errori.
ES:
3.times {p 'A'}
1.upto(3) {p 'B'} -> è come se fosse il for
3.downto(1) {p 'C'}
1.step(3,1) {p 'D'}
[1, 2].each{|x| p x}
NB:
una volta che una classe supporta l'each i metodi addizionali dell'enumerable sono disponibili
File.open('numbers.txt').grep(/e$/){|l| puts l} tutti quelli che finiscono per 'e'
* dato che file ha il metodo each posso ciclare su tutte le righe


TRA GLI ITERATORI C'E' ANCHE
LOOP
loop do
...
end
e
FOR..IN
che però è solo uno zucchero sintattico per il metodo each
a = [1, 2, 3]
a.each{|v| puts v}
for v in a
  puts v
end
quando ruby vede il for in lo traduce nel metodo each.
Tuttavia una differenza c'è e riguarda lo scope delle variabili che sono definite nel body del metodo






Quando si usano tutti queste cose è utile conoscere anche le parole chiave: break, redo, next. La parola chiave retry non c'è più. Con il ruby nuovo è stata rimossa.
questi permettono di alterare il flusso normale dell'iteratore
break esce dal ciclo
next salta il giro
redo riprova dall'inizio del ciclo




