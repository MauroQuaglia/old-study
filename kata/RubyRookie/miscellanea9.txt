Espressioni



Quello che per C# o Java è un'istruzione, per Ruby è un'espressione.
my_if = if 0 == 0
          'ciao'
         end
poi quando chiamo la my_if, la esegue.



Posso ridefinire un'operazione usando la parola alias:
class Fixnum
  alias old_plus +
end
2 + 5 = 7
2.old_plus(5) = 7

class Fixnum
  alias old_plus +
  def +(other)
    self.succ
  end
end
1 + 3 = 2
1.old_plus(3) = 4



Posso definire su una mia classi tutti i metodi che voglio, come quelli usati normalmente:
<< (che poi torna self), [] indexing



Se uso `` (backticks) o %x{} posso eseguire un comando relativo al mio sistema operativo
l'exit status è disponibile nella variabile $?
OSS:
anche ` è un metodo e può essere ridefinito.
Posso scriverlo ovunque senza specificare che riapro Object ()

alias old_backquote `
def `(cmd)
  result = old_backquote(cmd)
  if $? != 0
    puts "Command: [#{cmd}] failed with status: [#{$?.exitstatus}]!"
  end
  result
end



Assegnamento
semplice: a = 7 (a è una variabile o costante)
complesso: list.projects = [1,2] dove vado io ad implementare il setting projects sull'oggetto list.
il valore dell'assegnazione è sempre il valore del parametro, anche si poi ci metto un return!


Con Ruby si possono fare assegnazioni parallele.
a sx posso avere solo uno splat, a dx anche più di uno.
a, b, c, d = *(1..4)
a, *b = 1, 2, 3, *[1, 9]
g, *a, b = 1, 3, 9, 5
posso anche ignorare dei parametri con il solo asterisco
f, *, l = *(1..10)      f = 1, l = 10
Ci possono essere anche degli assegnamenti innestati
a, (b, c), d = 1, 2, 3, 4
a = 1
(b, c) = 2 -> b=2, c=nil
d=3



gli operatori ++ e -- non ci sono.
usiamo += e -=
tutto ciò che non è nil o false e true.

&&, and -> fanno la stessa cosa ma differiscono per priorità... similmente gli altri
and e && ritornano il primo membro se false, atrimenti valutano ed eventualmente ritornano il secondo membro.
nil && 99 = nil, true && 99 = 99
or e || ritornano il primo membro se true, atrimenti valutano ed eventualmente ritornano il secondo membro.
nil || 99 #99
'ciao' || nil # ciao

Un idioma comune è assegnare un valore a una variabile solo se non è ancora assegnato.
var ||= 'default' (che è uno shortcut per una cosa simile a var = var || 'default')
anche se le due espressioni sono leggermente differenti.
con ||= se la variabile è già settatat non viene fatto nessun assegnamento, con v = v || 'd' l'assegnamento viene fatto comunque.




defined?
nil se l'argomento non è definito
una descrizione se l'argomento è definito.
defined? 1 -> espressione
defined? x -> nil
defined? print -> method

gli oggetti ruby supportano il confronto grazie ai metodi
==, ===, <=>, =~, eql?, equal? -> tutti in classe object tranne <=>
OSS:
== stesso valore 1 == 1.0 ok
eql? stesso tipo e valore 1.0 e 1 sono eql? diversi
equal? stesso oggetto

ci sono anche le versioni negate di ==, != e =~, !~
# se le negazioni non sono definite, ruby cerca la definizione di == e nega il risultato. Vedi class T di esempio.
