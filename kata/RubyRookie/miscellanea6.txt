Numeri

* la classe base di tutti i numeri è Numeric.

* interi (Fixnum, Bignum) (N,I)
** come classe base hanno Integer (Integer è la classe base solo per queste due)
** possono avere qualsiasi lunghezza.
** vengono convertiti in automatico da Ruby in oggetti Fixnum o Bignum a seconda della dimensione.
** posso mettere davanti un carattere che ne indica la base in cui devono essere interpretati: 0 = ottale, 0d = decimale = default, 0x = esadecimale, 0b = binario.
** gli underscore vengono ignorati e servono solo per leggere meglio il numero

* virgola mobile (Float) (R)
** basta mettere un punto (.0) per trasformare un Fixnum in un Float, con il punto Ruby capisce che deve fare la conversione
** Venfono memorizzati in un oggetto Float (sia se espressi con virgola mobile, sia quando espressi con esponente)
** sia numeri con virgola mobile, es: 1.2 -> Float
** sia numeri con esponente, es: 5e0 = 5.0 * 10^0 = 5.0 * 1 = 5.0; 5e2 = 5.0 * 10^2 = 5.0 * 100 = 500.0 -> Float

* razionali (Rational) (Q)
** esprime il rapporto tra due numeri interi, sono delle frazioni. Dunque rispetto ai float hanno una rappresentazione "esatta" Es: 1 / 3 = 0.3333333333... che poi ruby arrotonda
** Es: Rational(3, 4) oppure Rational('3/4')

* complessi (Complex) (C)
** viene rappresentato come parte reale e parte immaginaria:
** Complex(1,1) = 1+1i

------------------------------------------------------------------------------------------------------------------------

Quando effettuo un'operazione tra due numeri di classi diverse, il risultato appartiene alla classe più generale delle due usate.
Attenzione alla divisione, se divido due interi il risultato è ancora un intero, così
1   / 2 = 0 (int / int = int)
1.0 / 2 = 0.5 (float / int = float)

Se vogliamo fare le cose più pulite, cioè vogliamo lavorare con i razionali fino alla fine, invece di usare i risultati in virgola mobile equivalenti possiamo
sfruttare la libreria mathn.
Senza mathn
* 22 / 7 -> Fixnum 3;
* i * i -> Complex -1+0i
Con mathn
* 22 / 7 -> Rational 22/7;
* i * i -> Fixnum -1

------------------------------------------------------------------------------------------------------------------------
Gli Integer supportano molte iterazioni: times, upto, downto, step (si può usare nei cicli profiquamente), ...
ES 3.times{print 'x', ' '}
Se non viene specificato il blocco torna un enumeratore, e dato che poi ho un enumeratore ci posso fare ulteriori operazioni
ES 10.downto(7).with_index{|num, idx| p "#{idx}: #{num}"}
------------------------------------------------------------------------------------------------------------------------

STRINGHE
* una stringa è una sequenza di caratteri tra due delimitatori
** caratteri stampabili
** dati binari (sono difficoltosi da rappresentare e quindi usiamo gli escape... questo permette in 'compilazione' di capire il carattere corretto)

* Delimitatore ' gli escape sono limitati a questi due
** carattere di escape = \
*** '\\' -> \
*** '\'' -> '

* Delimitatore ", molti caratteri di escape
** carattere di escape = \
*** \n = newline, \r = return, ...
*** esegue codice ruby operativo "#{code}". questo code può essere anche più di una semplice chiamata può anche essere del vero codice, posso definirci un metodo ed eseguirlo!

* Delimitatore here-documents
** a = <<ABC
...
ABC
** << parta da colonna 1
** <<- posso mettere l'indentazione che voglio
** ci possono essere anche here-documens multipli su una singola riga.

--encoding--
* ogni stringa ha associato un encoding che dipende dal file che contiene la stringa.
** in ruby 2 l'encoding di default è UTF-8
* oss. #{s} stampa la stringa e basta, #{s.inspect} stampa la stringa virgolettata
* # encoding: us-ascii in cima al file e la stringa s all'interno del file ha encoding US-ASCII
* # encoding: utf-8 in cima al file e la stringa s all'interno del file ha encoding UTF-8 (default)


--caratteri--
* non c'è una classe per i caratteri.
* sono semplicemente stringhe di lunghezza uno
* possono essere creati mettendo un ? davanti al carattere o alla sequenza che rappresenta il carattere
* es: ?a, ?\C-a
** chissenefrega.... usiamo 'a' al posto di ?a che è più chiaro!


--lavorare con le stringhe--
* posso definire una classe song al volo: song = Struct.new(:title, :name, :length)
* le assegnazioni multilinea sono utili per esempio in questo caso
** length, name, title = line.chomp.split(/\s*\|\s*/) -> rende più chiara la sintassi della riga del file
** a, b = [1, 2] -> a = 1, b= 2.......


--range--
un range ha vari metodi che ti permettono di accedere al contenuto del range, max, include, ....

un range può anche essere basato su degli oggetti, non solo su stringhe e numeri
** deve avere il metodo "succ"
** e deve avere il metodo astronave (spaceship operator) <=>
anche se questa cosa di solito si usa poco


serve per implementare tre cose

* sequenze
** .. inclusivo, ... esclude l'ultimo elemento.
** posso convertirla in un array o in un enumeratore

* condizioni
** può essere usato come espressione condizionale, può funzionare come un interruttore on-off
** on quando la condizione nella prima parte è vera
** off quando la condizione nella seconda parte è vera
** esempio se leggo un file posso dire
*** puts line if line =~ /start/ .. line =~ /end/ (cioè se la prima parola è start e l'ultima è end)


* intervalli
** serve per vedere se un valore sta in un intervallo, dobbiamo usare l'operatore ===
** p (1..5) === 2, p (1..5) === 3.14 -> entrambe vere.
** si usa per esempio in un case quando devo verificare un continuo nell'intervallo


