Regular Expressions
* vedere se la stringa matcha un pattern;   // =~ S, // !~ S (vale anche S =~ //, S !~ //)
* cambiare una stringa;   sub, gsub
* estrarre da una stringa dei valori;

* carrattei riservati: . | ( ) [ ] { } + \ ^ $ * ?
* se li voglio usare come caratteri che devono matchare in una stringa, nella regex devo mettere davanti il simbolo: \
* devo usare il \ anche per il carattere / a meno di non usare la sintassi Regexp.new o %r{}.
** es: /\*/ match del carattere *, in questo caso avendo l'escape viene considerato come un carattere come tutti gli altri

------------------------------------------------------------------------------------------------------------------------

VEDERE SE LA STRINGA MATCHA UN PATTERN
* Sintassi:
stringa =~ /regex/ -> num o nil
/regex/ =~ stringa -> num o nil
stringa !~ /regex/ -> true o false
/regex/ !~ stringa -> true o false

* /cat/ è una regex come "cat" è una stringa
* il match ritorna un numero che è la posizione dove comincia il match nella stringa altrimenti nil.
* quindi con la sintassi stringa =~ /regex/ ho in uscita un true se il match c'è, perchè mi ritorna un numero che vale
true, o false se non c'è il match perchè nil è come false.

Altri esempi di sintassi:
/a/ =~ 'cane' -> 1
/a/.match('cane') -> torna un oggetto MatchData
Regexp.new('a').match('cane') -> torna un oggetto MatchData
In sostanza quando chiamo il match, mi torna un MatchData
Se il match fallisce tutti tornano nil

Differenza fra =~ e .match
* Con =~ ho a disposizione le variabili $&, $`, $' che contengono informazioni sul match.
** Sono variabili globali, e sono brutte da vedere e utilizare. ($` + $& + $' riottengo la stringa originaria)
** Sono il pre_match, il match e il post match.
* Con .match ho a disposizione i metodi pre_match, post_match, [0]
** Comunque riempie anche le variabili $ precedenti ma le stesse informazioni ora le posso chiedere a un oggetto.
** result.pre_match + result[0]  + result.post_match è la stringa originaria

------------------------------------------------------------------------------------------------------------------------

CAMBIARE UNA STRINGA
* sub -> cambia solo il primo match
* gsub -> li cambia tutti (global sub)

NB
* sub è diverso da sub!
** a parte la differenza data dal bang method, se sub non matcha ritorna la stringa originaria, invece sub! tonra nil.

------------------------------------------------------------------------------------------------------------------------

ANCORA SULLA REGEX

La regex è un oggetto, in quanto istanza della classe Regexp e come tale può essere assegnato ad una variabile.
Ci sono diversi modi per istanziare una regexp
p1 = /mm\/dd/
p2 = Regexp.new('mm/dd') -> utile per regexp che contengono il carattere /
p3 = %r{mm/dd}  -> utile per regexp che contengono il carattere /

OPZIONI (esempio)
Ce ne sono molte, questo è un esempio del case insensitive.
i -> case insensitive; /cat/i    Regexp.new('cat', 'i')   %r{cat}i
Si può specificare anche l'encoding della regular expression, normalmente usa quello del file in cui si trova.

------------------------------------------------------------------------------------------------------------------------

CARATTERI RISERVATI
E' solo un'infarinatura, ci sarebbero troppi dettagli e servirebbe un libro solo per le regexp.



ANCORE
Matchano solo all'inizio di una stringa: ^, \A
* Come dire, la stringa deve iniziare per ...
* /^123/ -> la stringa deve iniziare per 123

Matchano solo alla fine di una stringa:  $, \Z
* Come dire, la stringa deve finire per ...
* /123$/ -> la stringa deve finire per 123

Bordi: \b, \B
* Marchanto la stringa esatta, con o senza spazi.
 ** /\bcat\b/ matcha solo la parola cat, se scrivo xcatx non trova nessun match.



CLASSI DI CARATTERI
* E' un insieme di caratteri tra [].
** Ci posso mettere anche i caratteri speciali tuttavia i i caratteri del tipo \n, \s, ... rappresentano comunque
nuova riga, spazio, ...
** Se ci metto dei -, vuoli dire tutto quello tra gli estremi: [A-Z]
** Posso negare una classe di caratteri merdiante il simbolo ^: [^A-Z]
** alcune classi di caratteri sono molto utilizzate perc cui ci sono delle abbreviazioni. \d = [0-9]. Possono essere
usate sia nel pattern che nella classe di caratteri.
* Possiamo dire alla Regexp come interpretare i caratteri. (?d) default, (?a) ASCII, (?u) UNICODE (cosa nuova di ruby 2)
* Se all'interno delle [] voglio usare le [] o i - li devo escapare, infatti nelle le classi di caratteri si
scivono con questi caratteri [ ] -, quindi per forza li devo escapare.
* Posso creare intersezioni di caratteri di classi usando &&. Es: tutte le non vocali:  /[[a-z]&&[^aeiou]]/
* lo \p permette di matchare caratteri speciali come quelli matematici che hanno codifiche particolari. Es: /\p{Alnum}/
* il punto (fuori dalle parentesi) . rappresenta qualsiasi carattere eccetto la newline.



RIPETIZIONI
r = regular expression
r*     -> 0+
r+     -> 1+
r?     -> 01
r{m,n} -> almeno m e al massimo n
r{m,}  -> almeno m
r{,n}  -> al massimo n
r{m}   -> m

Questi operatori hanno una precedenza alta così che /ab+/ non significa che matcha una sequenza di ab, ma matcha a
seguita da una o più b.
Sono definiti operatori avidi perché matchano tutto quello che possono e poi ritornao.
La versione lazy che esce appena la condizione è soddisfatta si ottiene aggiungendo un ?
avido /\s.*\s/    moon is made of
lazy  /\s.*?\s/   moon



ALTERNANZA
Il | la escapiamo perchè altrimenti significa una cosa O un'altra. d|e significa d oppure e.
Il | ha una precedenza molto bassa:
/red ball|angry sky/ matcha [red ball] o [angry sky] e non [red ball sky] o [red angry sky].
Per ottenere l'ultimo match dobbiamo overraidare il default e usare il raggruppamento.



RAGGRUPPAMENTO
Si possono usare le () per raggruppare le regexp, ogni cosa tra () viene trattata come una regexp a se.
banana /an+/   -> an
banana /(an)+/ -> anan

I risultati nei match delle () sono disponibili come variabili globali:
/(\d\d):(\d\d)/ =~ '12:50'
"Hour #$1, minute #$2" ---> "Hour 12, minute 50"

Se invece uso un MatchData abbiamo l'analogo:
md = /(\d\d):(\d\d)/.match('12:50')
"Hour #{md[1]}, minute #{md[2]}"  ---> "Hour 12, minute 50"

