Le eccezioni impacchettano informazioni circa un errore avvenuto in un oggetto.
Quando viene sollevata viene inoltrata nello stack finché non trova qualcuno che si prende carico di gestirla.
Le informazioni vengono incapsulate in un oggetto Exception o in un suo figlio.

Quando lancio un'eccezione posso usare una di quelle già predefinite in Ruby (146) oppure ne posso creare
io una nuova ma deve derivare da StandardError o uno dei suoi figli, altrimenti non viene agganciata per default.
A ogni eccezione si può associare un messaggio e uno stack backtrace.

OSS
open-uri permette di scaricare pagine web e salvarle in un file.

------------------------------------------------------------------------------------------------------------------------

COSTRUTTO PER LA GESTIONE DELLE ECCEZIONI

begin
    ...
    ...
rescue Exception
    ...
    # un riferimento all'eccezione presa è contenuta nella variabile globale $!
    raise # se la voglio rilanciare (lui in automatico rilancia $!), altrimenti non metto niente.
    retry # se volgio (o posso) correggere il motivo di eccezione e riprovare ad eseguire il blocco begin ..end. Da usare con molta cautela, perché potrei entrarein cicli infiniti!
else
    ...
    viene eseguita solo se non ci sono state eccezioni e prima del blocco ensure
    ...
ensure
    ... #operazioni finali. viene sempre eseguito
    ...
end

un'alternativa ad usare $! e definire la variabile locale che contiene l'eccezione corrente
begin
    ...
rescue Exception => boom
    ...
end




ci possono essere più rescue per gestire le eccezioni
begin
    ...
rescue StandardError, NameError => boom
    ...
rescue SecurityError => security
    ...
end
ma come fa a capire il match?   usa (parameter === $!)    (=== come quello che usa il case e $! è l'eccezione che è stata lanciata)



OSS
se scrivo rescue senza specificare niente il default è lo StandardError
se nessuna rescue va a buon fine o se l'accezione è lanciata al di fuore del blocco begin .. end cerca ruby un gestore di eccezione nel chiamante e nel chiamante del chiamante e così via...



----
errori di sistema (system error)
vengono lanciate quando un errore di sistema ritorna un codice di errore (error code). (EAGAIN, ...) con 'man errno' su linux li posso vedere
ruby li decora con uno specifico oggetto e ce li mostra


----------------------


NB
i beginner di solito mettono l'apertura del file File.open dentro il blocco begin. E' sbagliato perchè open può lanciare un'eccezione
e se è così di solito non si vuole eseguire ciò che sta nel blocco ensure perchè non c'è nessun file da chiudere.

SBAGLIATO
begin
 file.open
rescue
...

GIUSTO
file.open
begin
...
rescue


------------------------

per lanciare un'eccezione nel codice posso usare (sono la stessa cosa, ma fail è più parlante di raise)
raise
fail (che è un sinonimo una RuntimeError)
#raise -> RuntimeError (o quella corrente)
#raise 'mp3' -> RuntimeError con messaggio
#raise NameError, 'mp3'  -> NameError con messaggio mp3
#raise NameError, 'mp3', caller -> lo stacktrace è prodotto usando Object#caller method




-------------------
catch and throw
- raise e rescue si usano quando qualcosa può andare storto.
se volgio abbandonare un ciclo perchè qualcosa non 'mi piace' devo usare il catch end throw, in tal caso niente è andato storto, voglio solo abbandonareil ciclo
esempio
catch(:done) do
      File.foreach('words.txt') do |line|
        throw :done if line.chomp! == 'egli'
        p line
      end
        p 'ciao'
    end
quando rilancio il simbolo :done esco.
la differenza è che con il break interrompo il ciclo ed esco, qui invece esco proprio dall'esecuzione del blocco , quindi è qualcosa in più che l'uscire
dal ciclo del foreach.
se passo un parametro al throw viene ritornato quel valore
value = catch(:done) do
      File.foreach('words.txt') do |line|
        throw :done, 'done-executed' if line.chomp! == 'egli'
        p line
      end
      p 'ciao'
    end
    p value
  end

il throw può anche non apparire nel contesto statico del catch